"""Base capability interface and models for infrastructure provisioning.

This module defines the abstract interface that all infrastructure capabilities
must implement, along with the data models used for capability execution.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Any


@dataclass
class CapabilityContext:
    """Context information passed to a capability for execution.

    Attributes:
        user_request: Original user request that triggered capability
        capability_name: Name of the capability being executed
        parameters: Validated parameters from orchestrator conversation
        metadata: Additional context (user info, session data, etc.)
    """

    user_request: str
    capability_name: str
    parameters: dict[str, Any]
    metadata: dict[str, Any] = field(default_factory=dict)


@dataclass
class CapabilityPlan:
    """Execution plan generated by a capability.

    This represents what the capability intends to do, presented to the
    user for review and approval before execution.

    Attributes:
        capability_name: Name of the capability
        description: Human-readable description of what will happen
        resources: List of resources that will be created/modified
        estimated_cost: Monthly cost estimate in USD (if applicable)
        estimated_duration: Expected deployment time in minutes
        requires_approval: Whether user approval is needed before execution
        details: Additional plan details (config values, terraform plan, etc.)
    """

    capability_name: str
    description: str
    resources: list[dict[str, Any]] = field(default_factory=list)
    estimated_cost: float | None = None
    estimated_duration: int | None = None
    requires_approval: bool = True
    details: dict[str, Any] = field(default_factory=dict)

    def to_summary(self) -> str:
        """Generate human-readable plan summary for user review."""
        lines = [
            f"**{self.capability_name}**",
            f"{self.description}",
            "",
            "**Resources to be created:**"
        ]

        for resource in self.resources:
            resource_type = resource.get("type", "Resource")
            resource_name = resource.get("name", "unnamed")
            lines.append(f"  - {resource_type}: {resource_name}")

        if self.estimated_cost is not None:
            lines.append(f"\n**Estimated cost**: ${self.estimated_cost:.2f}/month")

        if self.estimated_duration is not None:
            lines.append(f"**Estimated duration**: ~{self.estimated_duration} minutes")

        return "\n".join(lines)


@dataclass
class CapabilityResult:
    """Result of capability execution.

    Attributes:
        capability_name: Name of the capability that executed
        success: Whether execution succeeded
        message: Human-readable result message
        resources_created: List of resources that were created
        outputs: Capability-specific outputs (URLs, connection strings, etc.)
        error: Error message if execution failed
        duration_seconds: Actual execution time
    """

    capability_name: str
    success: bool
    message: str
    resources_created: list[dict[str, Any]] = field(default_factory=list)
    outputs: dict[str, Any] = field(default_factory=dict)
    error: str | None = None
    duration_seconds: float | None = None

    def to_summary(self) -> str:
        """Generate human-readable result summary."""
        if self.success:
            lines = [
                f"✅ **{self.capability_name}** - Success",
                f"{self.message}",
                ""
            ]

            if self.resources_created:
                lines.append("**Resources created:**")
                for resource in self.resources_created:
                    resource_type = resource.get("type", "Resource")
                    resource_name = resource.get("name", "unnamed")
                    lines.append(f"  - {resource_type}: {resource_name}")

            if self.outputs:
                lines.append("\n**Outputs:**")
                for key, value in self.outputs.items():
                    lines.append(f"  - {key}: {value}")

            if self.duration_seconds is not None:
                lines.append(f"\n⏱️ Duration: {self.duration_seconds:.1f} seconds")
        else:
            lines = [
                f"❌ **{self.capability_name}** - Failed",
                f"{self.message}",
            ]

            if self.error:
                lines.append(f"\n**Error**: {self.error}")

        return "\n".join(lines)


class BaseCapability(ABC):
    """Abstract base class for all infrastructure capabilities.

    Each capability represents a specific infrastructure provisioning operation
    (e.g., provision Databricks, provision OpenAI, configure firewall).

    Capabilities follow a two-phase execution model:
    1. Plan: Analyze requirements and generate execution plan
    2. Execute: Perform the actual infrastructure provisioning

    This allows for user review and approval between planning and execution.
    """

    @property
    @abstractmethod
    def name(self) -> str:
        """Unique identifier for this capability (e.g., 'provision_databricks')."""
        pass

    @property
    @abstractmethod
    def description(self) -> str:
        """Human-readable description of what this capability does."""
        pass

    @abstractmethod
    async def plan(self, context: CapabilityContext) -> CapabilityPlan:
        """Generate execution plan from user requirements.

        This method analyzes the user's request and context to determine:
        - What resources will be created
        - What configuration will be applied
        - Estimated cost and duration
        - Any validation errors or warnings

        Args:
            context: Context information including user request and parameters

        Returns:
            CapabilityPlan describing what will be executed

        Raises:
            ValueError: If required parameters are missing or invalid
            RuntimeError: If planning fails for other reasons
        """
        pass

    @abstractmethod
    async def execute(self, plan: CapabilityPlan) -> CapabilityResult:
        """Execute the capability based on approved plan.

        This method performs the actual infrastructure provisioning operation.
        It should be idempotent where possible and handle errors gracefully.

        Args:
            plan: Approved execution plan from plan() method

        Returns:
            CapabilityResult with execution status and outputs

        Raises:
            RuntimeError: If execution fails
        """
        pass

    async def validate(self, context: CapabilityContext) -> tuple[bool, list[str]]:
        """Validate that context has all required parameters.

        Optional method for pre-flight validation before planning.

        Args:
            context: Context to validate

        Returns:
            Tuple of (is_valid, list_of_error_messages)
        """
        return True, []

    async def rollback(self, result: CapabilityResult) -> bool:
        """Attempt to rollback/cleanup after failed execution.

        Optional method for error recovery. Not all capabilities support rollback.

        Args:
            result: Failed execution result to rollback

        Returns:
            True if rollback succeeded, False otherwise
        """
        return False
